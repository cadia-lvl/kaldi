# Grammar file to expand abbreviations, numbers and ordinals
#
# 2016 Inga Run Helgadottir
#
# This grammar can be interactively tested by doing:
#
# thraxrewrite-tester --far=local/abbreviate.far --rules=ABBREVIATE --noutput=1 --input_mode=utf8 --output_mode=utf8

# It can also be tested in the following way:
# thraxrewrite-fileio --far=local/abbreviate.far --rules=ABBREVIATE
# --noutput=1 --input_mode=utf8 --output_mode=utf8 <input-text-file>
# <output-text-file>

# NOTE! If the last word of the whole speech is a number it will not
# be correctly shortened. F.ex. "fjörutíu og tveir" would become "40
# og tveir" The NARROWNUMS_MAYBE transducer requires that a space
# follows the number

import 'local/common.grm' as c;
import 'local/numbers.grm' as n;
import 'local/ordinals.grm' as o;
# Use factorize since Robert already had introduced appropriate wheights
#import 'local/factorize.grm' as f;

# This transducer deletes a sequence of zero or more spaces:
delspace = c.space* : "".utf8;

insspace = "".utf8 : " ".utf8;

unitnames = n.units;
numbernames_10plus_and_0 = n.NUMBERNAMES_10_to_999999_and_0; #n.NUMBERNAMES_10plus_and_0;
ordinalnames = o.ORDINALNAMES2; # Does not expand 1. and 2.
ordinal = Invert[ordinalnames];
#namesnumber = f.NAMESNUMBER2;

units = Invert[unitnames];
#namesnumber = Invert[numbernames];
namesnumber_10plus_and_0 = Invert[numbernames_10plus_and_0];

# Abbreviations used in Alþingi paired with their expansions
abbr = Optimize[StringFile['text_norm/lex/abbreviate_words.txt','utf8','utf8']];
abbr2 =
Optimize[StringFile['text_norm/lex/abbreviate_if_preceded_wNumber.txt','utf8','utf8']];
abbr3 = Optimize[StringFile['text_norm/lex/abbreviate_if_followed_byNumber.txt','utf8','utf8']];
#kjordaemi = Optimize[StringFile['text_norm/lex/kjordaemi_abbr.txt','utf8','utf8']];

abbr_unit_CDbefore = Optimize[
                     CDRewrite[units,
                     ("númer".utf8 " ".utf8 |
                     "til".utf8 " ".utf8 | "komma".utf8 " ".utf8),
                     (" ".utf8 | "[EOS]".utf8),
                     c.whole_alphabet*,
                     'ltr',
                     'obl']];

abbr_unit_CDafter = Optimize[
                     CDRewrite[units,
                     ("[BOS]".utf8 | " ".utf8),
                     ( " ".utf8 "til".utf8 | " ".utf8 "komma".utf8
                     | " ".utf8 "og hálf".utf8 | " ".utf8 "prósent".utf8
                     | " ".utf8 "prómill".utf8 | " ".utf8 "gráð".utf8),
                     c.whole_alphabet*,
                     'ltr',
                     'obl']];

# I'm thinking about the case when I have f.ex. "zero point one three
# seven"
abbr_unit_CDbefore2 = Optimize[
                     CDRewrite[units,
                     (c.Digits " ".utf8),
                     (" ".utf8 | "[EOS]".utf8),
                     c.whole_alphabet*,
                     'ltr',
                     'obl']];

# export NARROWNUMS_MAYBE = ArcSort[Optimize[Determinize[
#                           CDRewrite[namesnumber insspace,
#                                     ("[BOS]".utf8 | " ".utf8),
#                                     ("[EOS]".utf8 | "".utf8),
#                                     c.whole_alphabet*,
#                                     'sim',
#                                     'obl']]],
#                                   'input'];

# This abbreviates at least one rewritable word or number, per
# senctence. But doesn't take in senctences containing numerals
# and/or abbreviations (written as f.ex. 2, 4, t.d., hv.)
# So we would loose utterances
#export exp_tmp = Optimize[rewrite @ optional_exp @ EXPAND_WORD ];
#export tmp = Invert[rewrite @ optional_exp @ word];
ABBR_WORD = Optimize[
                     CDRewrite[abbr delspace,
                     ("[BOS]".utf8 | " ".utf8),
                     ("[EOS]".utf8 | " ".utf8),
                     c.whole_alphabet*,
                     'ltr',
                     'obl']];

ABBR_NUMBER_10plus_and_0 = Optimize[
                     CDRewrite[namesnumber_10plus_and_0 delspace,
                     ("[BOS]".utf8 | " ".utf8),
                     ("[EOS]".utf8 | " ".utf8),
                     c.whole_alphabet*,
                     'ltr',
                     'obl']];

ABBR_NUMBER = Optimize[ABBR_NUMBER_10plus_and_0 @ abbr_unit_CDbefore @
abbr_unit_CDafter @ abbr_unit_CDbefore2];

ORDINAL = ArcSort[Optimize[Determinize[
                     CDRewrite[ordinal delspace,
                     ("[BOS]".utf8 | " ".utf8),
                     ("[EOS]".utf8 | " ".utf8),
                     c.whole_alphabet*,
                     'sim',
                     'obl']]],
                     'input']; # If have 'obl' instead, all "annars
                     # vegar" and "dag einn..." will be abbreviated

abbreviate1 = Optimize[ABBR_WORD @ ORDINAL @ ABBR_NUMBER];
#abbreviate1 = Optimize[ABBR_WORD @ ORDINAL @ NARROWNUMS_MAYBE];


# Could I here add a fst that works on the output of the first
# one. F.ex. checks if the previous word is a number??

ABBR_WORD2 = CDRewrite[abbr2 delspace,
                     (c.Digits+ ".".utf8? " ".utf8),
                     ("[EOS]".utf8 | " ".utf8),
                     c.whole_alphabet*,
                     'ltr',
                     'obl'];

nr = CDRewrite[("númer".utf8 : "nr".utf8) delspace,
               ("[BOS]".utf8 | " ".utf8),
               (" ".utf8 c.Digits+),
               c.whole_alphabet*,
               'ltr',
               'obl'];

abbreviate2 = ArcSort[Optimize[Determinize[abbreviate1 @ ABBR_WORD2 @ nr]],'input'];

ABBR_WORD3 = Optimize[
                     CDRewrite[abbr3 delspace,
                     ("[BOS]".utf8 | " ".utf8),
                     (" ".utf8 ("lög nr ".utf8 | "lögum nr ".utf8 |
                     "nr ".utf8)? c.Digits+ ".".utf8?),
                     c.whole_alphabet*,
                     'ltr',
                     'obl']];

# ABBR_KJORDAEMI = CDRewrite[kjordaemi delspace,
#                      (c.Digits+ ".".utf8 " ".utf8 "þingm".utf8
#                      c.alphabet+ " ".utf8),
#                      ("[EOS]".utf8 | " ".utf8),
#                      c.whole_alphabet*,
#                      'ltr',
#                      'obl'];

export ABBREVIATE = ArcSort[
                    Optimize[abbreviate2 @ ABBR_WORD3],
                    'input'];

ins_periods =
Optimize[StringFile['text_norm/lex/abbr_periods.txt','utf8','utf8']];

export INS_PERIODS = CDRewrite[ins_periods,
                     ("[BOS]".utf8 | " ".utf8),
                     ".".utf8? ("[EOS]".utf8 | " ".utf8),
                     c.whole_alphabet*,
                     'ltr',
                     'obl'];
